<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™‚åˆ»è¡¨ç¤º - 100ãƒŸãƒªç§’å˜ä½</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            color: white;
        }

        .time-container {
            text-align: center;
            padding: 20px;
            position: relative;
            z-index: 10;
        }

        .date-display {
            font-size: clamp(1.5rem, 4vw, 3rem);
            margin-bottom: 20px;
            opacity: 0.9;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .time-display {
            font-size: clamp(3rem, 12vw, 8rem);
            font-weight: bold;
            color: #ffffff;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            line-height: 1.1;
        }

        .milliseconds {
            color: #ffeb3b;
            font-weight: normal;
        }

        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 20;
        }

        .wake-lock-status {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 0.8rem;
            opacity: 0.6;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 15px;
            display: none;
            z-index: 20;
        }

        .wake-lock-active {
            color: #4caf50;
        }

        .wake-lock-inactive {
            color: #ff9800;
        }

        /* èƒŒæ™¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å›³å½¢ */
        .floating-shape {
            position: fixed;
            font-size: 6rem;
            opacity: 0.6;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            z-index: 5;
            color: #ffffff;
        }

        /* ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³èƒŒæ™¯ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        #speedCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }



        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 768px) {
            .floating-shape {
                font-size: 3rem;
            }
        }

        @media (max-width: 480px) {
            .floating-shape {
                font-size: 2rem;
            }
        }

        @media (max-width: 768px) {
            .time-container {
                padding: 10px;
            }
            
            .info {
                bottom: 10px;
                right: 10px;
                font-size: 0.8rem;
            }
        }

        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ */
        .time-display {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            }
            to {
                text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 255, 0.2);
            }
        }
    </style>
</head>
<body>
    <canvas id="speedCanvas"></canvas>
    
    <div class="time-container">
        <div class="date-display" id="dateDisplay"></div>
        <div class="time-display" id="timeDisplay"></div>
    </div>
    
    <div class="wake-lock-status" id="wakeLockStatus">
        ğŸ”’ ç”»é¢ã‚ªãƒ•é˜²æ­¢
    </div>
    
    <div class="info">
        100ãƒŸãƒªç§’ç²¾åº¦
    </div>

    <script>
        function updateTime() {
            const now = new Date();
            
            // æ—¥ä»˜ã®è¡¨ç¤º
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const weekdays = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
            const weekday = weekdays[now.getDay()];
            
            const dateStr = `${year}å¹´${month}æœˆ${day}æ—¥ (${weekday})`;
            
            // æ™‚åˆ»ã®è¡¨ç¤ºï¼ˆ100ãƒŸãƒªç§’å˜ä½ï¼‰
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const milliseconds = String(Math.floor(now.getMilliseconds() / 100));
            
            const timeStr = `${hours}:${minutes}:${seconds}.<span class="milliseconds">${milliseconds}</span>`;
            
            document.getElementById('dateDisplay').textContent = dateStr;
            document.getElementById('timeDisplay').innerHTML = timeStr;
        }

        // é€£ç¶šçš„ãªã‚«ãƒ©ãƒ¼å¤‰åŒ–ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³ã®è‰²å¤‰åŒ–ç”¨ï¼‰
        let colorTime = 0;
        const colorSpeed = 0.2; // è‰²å¤‰åŒ–ã®é€Ÿåº¦ï¼ˆå°ã•ã„ã»ã©ã‚†ã£ãã‚Šï¼‰

        function updateColorsGradually() {
            // colorTimeã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³ã®è‰²å¤‰åŒ–ã«ä½¿ç”¨
            colorTime++;
        }

        // èƒŒæ™¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å›³å½¢ç®¡ç†
        const shapes = ['â–¡', 'â—‹', 'â˜†', 'â–³', 'â—‡', 'â™¦', 'â™ ', 'â™£', 'â™¥', 'âœ¦', 'âœ§', 'â€»'];
        const activeShapes = [];
        const maxShapes = 5;
        const minShapes = 1;

        function createFloatingShape() {
            if (activeShapes.length >= maxShapes) return;

            const shape = document.createElement('div');
            shape.className = 'floating-shape';
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªå›³å½¢ã‚’é¸æŠ
            const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
            shape.textContent = randomShape;
            
            // ç”»é¢ã®4æ–¹å‘ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠï¼ˆä¸Šä¸‹å·¦å³ï¼‰
            const directions = ['top', 'bottom', 'left', 'right'];
            const direction = directions[Math.floor(Math.random() * directions.length)];
            
            let startX, startY, endX, endY;
            
            // æ–¹å‘ã«å¿œã˜ã¦é–‹å§‹ä½ç½®ã¨çµ‚äº†ä½ç½®ã‚’è¨­å®š
            switch (direction) {
                case 'top': // ä¸Šã‹ã‚‰ä¸‹ã¸
                    startX = Math.random() * window.innerWidth;
                    startY = -50;
                    endX = startX + (Math.random() - 0.5) * 300; // æ¨ªã«ã‚‚å°‘ã—ãšã‚Œã‚‹
                    endY = window.innerHeight + 50;
                    break;
                case 'bottom': // ä¸‹ã‹ã‚‰ä¸Šã¸
                    startX = Math.random() * window.innerWidth;
                    startY = window.innerHeight + 50;
                    endX = startX + (Math.random() - 0.5) * 300;
                    endY = -50;
                    break;
                case 'left': // å·¦ã‹ã‚‰å³ã¸
                    startX = -50;
                    startY = Math.random() * window.innerHeight;
                    endX = window.innerWidth + 50;
                    endY = startY + (Math.random() - 0.5) * 300; // ç¸¦ã«ã‚‚å°‘ã—ãšã‚Œã‚‹
                    break;
                case 'right': // å³ã‹ã‚‰å·¦ã¸
                    startX = window.innerWidth + 50;
                    startY = Math.random() * window.innerHeight;
                    endX = -50;
                    endY = startY + (Math.random() - 0.5) * 300;
                    break;
            }
            
            // åˆæœŸä½ç½®ã‚’è¨­å®š
            shape.style.left = startX + 'px';
            shape.style.top = startY + 'px';
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ï¼ˆ10-20ç§’ï¼‰
            const duration = 10 + Math.random() * 10;
            
            // ç§»å‹•è·é›¢ã‚’è¨ˆç®—
            const deltaX = endX - startX;
            const deltaY = endY - startY;
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªå›è»¢
            const rotationDegrees = 360 + Math.random() * 360; // 1-2å›è»¢
            
            const keyframeName = `float-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            
            // ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å‹•çš„ã«ä½œæˆ
            const style = document.createElement('style');
            style.textContent = `
                @keyframes ${keyframeName} {
                    0% {
                        transform: translate(0px, 0px) rotate(0deg) scale(0.5);
                        opacity: 0;
                    }
                    10% {
                        opacity: 0.6;
                    }
                    90% {
                        opacity: 0.6;
                    }
                    100% {
                        transform: translate(${deltaX}px, ${deltaY}px) rotate(${rotationDegrees}deg) scale(1.2);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®š
            shape.style.animationName = keyframeName;
            shape.style.animationDuration = duration + 's';
            shape.style.animationTimingFunction = 'linear';
            shape.style.animationIterationCount = '1';
            shape.style.animationFillMode = 'forwards';
            
            // ã‚ˆã‚Šã¯ã£ãã‚Šã—ãŸè‰²å‘³
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8', '#ffd93d', '#6c5ce7', '#a29bfe'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            shape.style.color = randomColor;
            
            document.body.appendChild(shape);
            activeShapes.push({element: shape, style: style});
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†æ™‚ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            shape.addEventListener('animationend', () => {
                if (shape.parentNode) {
                    shape.parentNode.removeChild(shape);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
                const index = activeShapes.findIndex(s => s.element === shape);
                if (index > -1) {
                    activeShapes.splice(index, 1);
                }
            });
        }

        function manageFloatingShapes() {
            // æœ€å°æ•°ã‚’ä¸‹å›ã£ã¦ã„ã‚‹å ´åˆã¯å³åº§ã«è¿½åŠ 
            if (activeShapes.length < minShapes) {
                createFloatingShape();
            }
            // ãƒ©ãƒ³ãƒ€ãƒ ã«æ–°ã—ã„å›³å½¢ã‚’è¿½åŠ ï¼ˆ50%ã®ç¢ºç‡ã«ä¸Šã’ã‚‹ï¼‰
            else if (activeShapes.length < maxShapes && Math.random() < 0.5) {
                createFloatingShape();
            }
        }

        // å›³å½¢ç®¡ç†ã‚’1ç§’ã”ã¨ã«å®Ÿè¡Œï¼ˆé »åº¦ã‚’ä¸Šã’ã‚‹ï¼‰
        setInterval(manageFloatingShapes, 1000);

        // 100ãƒŸãƒªç§’ã”ã¨ã«è‰²ã‚’æ›´æ–°ï¼ˆæ™‚åˆ»æ›´æ–°ã¨åŒã˜é »åº¦ï¼‰
        setInterval(updateColorsGradually, 100);

        // 100ãƒŸãƒªç§’ã”ã¨ã«æ™‚åˆ»æ›´æ–°
        setInterval(updateTime, 100);
        
        // åˆå›å®Ÿè¡Œ
        updateTime();

        // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½ï¼ˆãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§åˆ‡ã‚Šæ›¿ãˆï¼‰
        document.addEventListener('dblclick', function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // ESCã‚­ãƒ¼ã§ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³çµ‚äº†
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && document.fullscreenElement) {
                document.exitFullscreen();
            }
        });

        // Wake Lock API ã§ç”»é¢ã‚’æ¶ˆã•ãªã„ã‚ˆã†ã«ã™ã‚‹
        let wakeLock = null;
        const wakeLockStatus = document.getElementById('wakeLockStatus');

        function updateWakeLockStatus(isActive) {
            if (wakeLockStatus) {
                wakeLockStatus.style.display = 'block';
                wakeLockStatus.className = `wake-lock-status ${isActive ? 'wake-lock-active' : 'wake-lock-inactive'}`;
                wakeLockStatus.textContent = isActive ? 'ğŸ”’ ç”»é¢ã‚ªãƒ•é˜²æ­¢ä¸­' : 'âš ï¸ ç”»é¢ã‚ªãƒ•é˜²æ­¢ç„¡åŠ¹';
                
                // 5ç§’å¾Œã«éè¡¨ç¤º
                setTimeout(() => {
                    if (wakeLockStatus) {
                        wakeLockStatus.style.display = 'none';
                    }
                }, 5000);
            }
        }

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸ');
                    updateWakeLockStatus(true);
                    
                    // Wake Lock ãŒè§£é™¤ã•ã‚ŒãŸæ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸ');
                        updateWakeLockStatus(false);
                        wakeLock = null;
                    });
                } catch (err) {
                    console.log('Wake Lock ã®å–å¾—ã«å¤±æ•—:', err);
                    updateWakeLockStatus(false);
                }
            } else {
                console.log('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Wake Lock APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“');
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å®šæœŸçš„ãªç”»é¢ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£
                startScreenKeepAlive();
            }
        }

        // Wake Lock API ãŒä½¿ãˆãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        function startScreenKeepAlive() {
            // 5åˆ†ã”ã¨ã«å°ã•ãªè¦ç´ ã‚’ç‚¹æ»…ã•ã›ã¦ç”»é¢ã‚’ã€Œã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã€ã«ä¿ã¤
            setInterval(() => {
                const dummy = document.createElement('div');
                dummy.style.position = 'absolute';
                dummy.style.opacity = '0.001';
                dummy.style.left = '-1px';
                dummy.style.top = '-1px';
                dummy.style.width = '1px';
                dummy.style.height = '1px';
                document.body.appendChild(dummy);
                
                setTimeout(() => {
                    if (dummy.parentNode) {
                        dummy.parentNode.removeChild(dummy);
                    }
                }, 100);
            }, 300000); // 5åˆ†
        }

        // ãƒšãƒ¼ã‚¸ãŒå†ã³è¡¨ç¤ºã•ã‚ŒãŸæ™‚ã«Wake Lockã‚’å†å–å¾—
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // ====== ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³èƒŒæ™¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ======
        const speedCanvas = document.getElementById('speedCanvas');
        const ctx = speedCanvas.getContext('2d');
        let animationRunning = true;
        let resizeTimeout = null;
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¨­å®š
        function resizeCanvas() {
            speedCanvas.width = window.innerWidth;
            speedCanvas.height = window.innerHeight;
        }
        resizeCanvas();
        
        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ä»˜ããƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆ
        window.addEventListener('resize', function() {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(resizeCanvas, 100);
        });
        
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³ï¼‰ã‚¯ãƒ©ã‚¹
        class SpeedLine {
            constructor() {
                this.reset();
            }
            
            reset() {
                // ç”»é¢ä¸­å¿ƒã‹ã‚‰ã®è§’åº¦
                this.angle = Math.random() * Math.PI * 2;
                // ä¸­å¿ƒã‹ã‚‰ã®è·é›¢ï¼ˆå°ã•ã„å€¤ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆï¼‰
                this.distance = Math.random() * 50;
                // é€Ÿåº¦
                this.speed = 2 + Math.random() * 8;
                // ç·šã®é•·ã•
                this.length = 20 + Math.random() * 80;
                // è‰²ã®æ˜ã‚‹ã•
                this.brightness = 0.3 + Math.random() * 0.7;
                // è‰²ç›¸ï¼ˆç¾åœ¨ã®èƒŒæ™¯è‰²ã«åˆã‚ã›ã¦å¤‰åŒ–ï¼‰
                this.hue = Math.random() * 60 - 30; // -30 ~ 30åº¦ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            }
            
            update() {
                // è·é›¢ã‚’å¢—åŠ ï¼ˆåŠ é€ŸåŠ¹æœï¼‰
                this.distance += this.speed * (1 + this.distance * 0.003);
                
                // ç”»é¢å¤–ã«å‡ºãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                const maxDistance = Math.max(speedCanvas.width, speedCanvas.height);
                if (this.distance > maxDistance) {
                    this.reset();
                }
            }
            
            draw(baseHue) {
                const centerX = speedCanvas.width / 2;
                const centerY = speedCanvas.height / 2;
                
                // ç¾åœ¨ã®ä½ç½®
                const x = centerX + Math.cos(this.angle) * this.distance;
                const y = centerY + Math.sin(this.angle) * this.distance;
                
                // ç·šã®çµ‚ç‚¹ï¼ˆå¾Œã‚å´ï¼‰
                const tailDistance = Math.max(0, this.distance - this.length);
                const tailX = centerX + Math.cos(this.angle) * tailDistance;
                const tailY = centerY + Math.sin(this.angle) * tailDistance;
                
                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
                const gradient = ctx.createLinearGradient(tailX, tailY, x, y);
                const hue = (baseHue + this.hue + 360) % 360;
                gradient.addColorStop(0, `hsla(${hue}, 80%, 70%, 0)`);
                gradient.addColorStop(1, `hsla(${hue}, 80%, 70%, ${this.brightness * 0.6})`);
                
                // ç·šã‚’æç”»
                ctx.beginPath();
                ctx.moveTo(tailX, tailY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1 + this.brightness * 2;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }
        
        // ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³ã®é…åˆ—
        const speedLines = [];
        const numSpeedLines = 100;
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºãŒç¢ºå®šã—ã¦ã‹ã‚‰åˆæœŸåŒ–
        const initialMaxDistance = Math.max(speedCanvas.width || window.innerWidth, speedCanvas.height || window.innerHeight);
        for (let i = 0; i < numSpeedLines; i++) {
            const line = new SpeedLine();
            // åˆæœŸé…ç½®ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†æ•£
            line.distance = Math.random() * initialMaxDistance;
            speedLines.push(line);
        }
        
        // æµã‚Œæ˜Ÿã®ã‚ˆã†ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        class FlowParticle {
            constructor() {
                this.reset();
            }
            
            reset() {
                // ç”»é¢ã®å·¦å´ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
                this.x = -10;
                this.y = Math.random() * speedCanvas.height;
                // å³æ–¹å‘ã¸ã®é€Ÿåº¦
                this.vx = 8 + Math.random() * 15;
                // ã‚ãšã‹ãªä¸Šä¸‹ã®å‹•ã
                this.vy = (Math.random() - 0.5) * 2;
                // å°¾ã®é•·ã•
                this.tailLength = 30 + Math.random() * 70;
                // ã‚µã‚¤ã‚º
                this.size = 1 + Math.random() * 2;
                // æ˜ã‚‹ã•
                this.brightness = 0.4 + Math.random() * 0.6;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                // ç”»é¢å¤–ã«å‡ºãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                if (this.x > speedCanvas.width + 100) {
                    this.reset();
                }
            }
            
            draw(baseHue) {
                const tailX = this.x - this.tailLength;
                
                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
                const gradient = ctx.createLinearGradient(tailX, this.y, this.x, this.y);
                const hue = (baseHue + 180) % 360; // è£œè‰²ç³»
                gradient.addColorStop(0, `hsla(${hue}, 70%, 80%, 0)`);
                gradient.addColorStop(1, `hsla(${hue}, 70%, 80%, ${this.brightness * 0.5})`);
                
                // ç·šã‚’æç”»
                ctx.beginPath();
                ctx.moveTo(tailX, this.y);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = this.size;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }
        
        // æµã‚Œãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®é…åˆ—
        const flowParticles = [];
        const numFlowParticles = 30;
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºãŒç¢ºå®šã—ã¦ã‹ã‚‰åˆæœŸåŒ–
        const initialWidth = speedCanvas.width || window.innerWidth;
        for (let i = 0; i < numFlowParticles; i++) {
            const particle = new FlowParticle();
            // åˆæœŸé…ç½®ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†æ•£
            particle.x = Math.random() * initialWidth;
            flowParticles.push(particle);
        }
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animateSpeedBackground() {
            if (!animationRunning) {
                requestAnimationFrame(animateSpeedBackground);
                return;
            }
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢ï¼ˆåŠé€æ˜ã§ãƒˆãƒ¬ã‚¤ãƒ«åŠ¹æœï¼‰
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, speedCanvas.width, speedCanvas.height);
            
            // ç¾åœ¨ã®èƒŒæ™¯è‰²ç›¸ã‚’å–å¾—
            const baseHue = (colorTime * colorSpeed) % 360;
            
            // ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’æ›´æ–°ãƒ»æç”»
            speedLines.forEach(line => {
                line.update();
                line.draw(baseHue);
            });
            
            // æµã‚Œãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ›´æ–°ãƒ»æç”»
            flowParticles.forEach(particle => {
                particle.update();
                particle.draw(baseHue);
            });
            
            requestAnimationFrame(animateSpeedBackground);
        }
        
        // ãƒšãƒ¼ã‚¸ã®å¯è¦–æ€§ã«å¿œã˜ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆ¶å¾¡
        document.addEventListener('visibilitychange', function() {
            animationRunning = document.visibilityState === 'visible';
        });
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        animateSpeedBackground();

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã®å‡¦ç†
        window.addEventListener('load', async function() {
            const info = document.querySelector('.info');
            const originalText = info.textContent;
            
            // Wake Lock ã‚’é–‹å§‹
            await requestWakeLock();
            
            // åˆå›ã‚«ãƒ©ãƒ¼æ›´æ–°ã‚’é–‹å§‹
            updateColorsGradually();
            
            // åˆå›å›³å½¢ã‚’è¤‡æ•°è¡¨ç¤º
            createFloatingShape();
            setTimeout(() => createFloatingShape(), 500);
            setTimeout(() => createFloatingShape(), 1000);
            
            // æƒ…å ±è¡¨ç¤ºã®æ›´æ–°
            let infoText = '100ãƒŸãƒªç§’ç²¾åº¦ | ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ | ç–¾èµ°æ„Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³';
            if ('wakeLock' in navigator) {
                infoText += ' | ç”»é¢ã‚ªãƒ•é˜²æ­¢ä¸­';
            }
            info.textContent = infoText;
            
            setTimeout(() => {
                info.textContent = originalText;
            }, 5000);
        });
    </script>
</body>
</html>